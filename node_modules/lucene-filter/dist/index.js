(() => {
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };

  // src/implicit.js
  var require_implicit = __commonJS({
    "src/implicit.js"(exports, module) {
      var implicit = module.exports = function(data, test) {
        return Object.keys(data).reduce((r, key) => {
          return r || require_field()(key, data, test);
        }, false);
      };
    }
  });

  // src/field.js
  var require_field = __commonJS({
    "src/field.js"(exports, module) {
      var field = module.exports = function(field2, data, test) {
        if (field2 === "<implicit>")
          return require_implicit()(data, test);
        return test(data[field2]);
      };
    }
  });

  // src/filters/regexp.js
  var require_regexp = __commonJS({
    "src/filters/regexp.js"(exports, module) {
      var field = require_field();
      module.exports = {
        detect: function(query) {
          if (!query)
            return false;
          if (typeof query !== "object")
            return false;
          return !!query.regexpr || !!query.regex;
        },
        compile: function(query) {
          const regex = new RegExp(query.term);
          return function(data) {
            return field(query.field, data, function(value) {
              return regex.test(value);
            }) ? query.boost : 0;
          };
        }
      };
    }
  });

  // src/filters/number/range.js
  var require_range = __commonJS({
    "src/filters/number/range.js"(exports, module) {
      var field = require_field();
      module.exports = {
        detect: function(query) {
          if (!query)
            return false;
          if (typeof query !== "object")
            return false;
          if (!("inclusive" in query))
            return false;
          if (isNaN(query.term_min))
            return false;
          return !isNaN(query.term_max);
        },
        compile: function(query) {
          return function(data) {
            return field(query.field, data, function(value) {
              let min = parseFloat(query.term_min);
              let max = parseFloat(query.term_max);
              let inclusive = query.inclusive;
              if (inclusive === "both") {
                return value >= min && value <= max;
              }
              if (inclusive === "left") {
                return value >= min && value < max;
              }
              if (inclusive === "right") {
                return value > min && value <= max;
              }
              return false;
            });
          };
        }
      };
    }
  });

  // src/filters/number/exact.js
  var require_exact = __commonJS({
    "src/filters/number/exact.js"(exports, module) {
      var field = require_field();
      module.exports = {
        detect: function(query) {
          if (!query)
            return false;
          if (typeof query !== "object")
            return false;
          if (!query.term)
            return false;
          return !isNaN(query.term);
        },
        compile: function(query) {
          query.similarity = query.similarity || 0;
          return function(data) {
            return field(query.field, data, function(value) {
              value = parseFloat(value);
              let min = parseFloat(query.term) - query.similarity;
              let max = parseFloat(query.term) + query.similarity;
              return min <= value && value <= max;
            }) ? query.boost : 0;
          };
        }
      };
    }
  });

  // src/filters/number/comparison.js
  var require_comparison = __commonJS({
    "src/filters/number/comparison.js"(exports, module) {
      var field = require_field();
      module.exports = {
        detect: function(query) {
          if (!query) {
            return false;
          }
          if (typeof query !== "object") {
            return false;
          }
          if (!query.term) {
            return false;
          }
          return Array.isArray(query.term.match(/^[<=>]+/));
        },
        compile: function(query) {
          query.similarity = query.similarity || 0;
          return function(data) {
            return field(query.field, data, function(value) {
              let sign, num;
              value = parseFloat(value);
              if (sign = query.term.match(/^[<=>]+/)) {
                [sign] = sign;
              }
              num = query.term.match(/[0-9.]+/);
              if (!num) {
                return false;
              }
              num = Number(num[0]);
              if (sign) {
                if (sign === ">") {
                  return value > num;
                } else if (sign === ">=") {
                  return value >= num;
                } else if (sign === "<") {
                  return value < num;
                } else if (sign === "<=") {
                  return value <= num;
                } else {
                  throw new Error(`Invalid sign: ${sign}`);
                }
              } else {
                return value === num;
              }
            });
          };
        }
      };
    }
  });

  // src/filters/string/starts-with.js
  var require_starts_with = __commonJS({
    "src/filters/string/starts-with.js"(exports, module) {
      var field = require_field();
      module.exports = {
        detect: function(query) {
          if (!query)
            return false;
          if (typeof query !== "object")
            return false;
          if (typeof query.field !== "string")
            return false;
          return query.field.substr(-1) === "*";
        },
        compile: function(query) {
          query.field = query.field.substr(0, query.field.length - 1);
          return function(data) {
            return field(query.field, data, function(value) {
              if (typeof value !== "string")
                return false;
              return value.toLowerCase().substr(0, query.term.length) === query.term.toLowerCase();
            }) ? query.boost : 0;
          };
        }
      };
    }
  });

  // src/filters/string/ends-with.js
  var require_ends_with = __commonJS({
    "src/filters/string/ends-with.js"(exports, module) {
      var field = require_field();
      module.exports = {
        detect: function(query) {
          if (!query)
            return false;
          if (typeof query !== "object")
            return false;
          if (typeof query.field !== "string")
            return false;
          return query.field.substr(0, 1) === "*";
        },
        compile: function(query) {
          query.field = query.field.substr(1);
          return function(data) {
            return field(query.field, data, function(value) {
              if (typeof value !== "string")
                return false;
              return value.toLowerCase().substr(-query.term.length) === query.term.toLowerCase();
            }) ? query.boost : 0;
          };
        }
      };
    }
  });

  // src/filters/string/contains.js
  var require_contains = __commonJS({
    "src/filters/string/contains.js"(exports, module) {
      var field = require_field();
      module.exports = {
        detect: function(query) {
          if (!query)
            return false;
          if (typeof query !== "object")
            return false;
          if (typeof query.field !== "string")
            return false;
          return typeof query.term === "string";
        },
        compile: function(query) {
          return function(data) {
            return field(query.field, data, function check(value) {
              if (typeof value === "string") {
                return ~value.toLowerCase().indexOf(query.term.toLowerCase());
              } else if (Array.isArray(value)) {
                for (const v of value)
                  if (check(v))
                    return true;
                return false;
              } else {
                return false;
              }
            }) ? query.boost : 0;
          };
        }
      };
    }
  });

  // src/filters/index.js
  var require_filters = __commonJS({
    "src/filters/index.js"(exports, module) {
      var filters = module.exports = [];
      filters.push(require_regexp());
      filters.push(require_range());
      filters.push(require_exact());
      filters.push(require_comparison());
      filters.push(require_starts_with());
      filters.push(require_ends_with());
      filters.push(require_contains());
    }
  });

  // src/operators/or.js
  var require_or = __commonJS({
    "src/operators/or.js"(exports, module) {
      module.exports = (l, r) => (data) => {
        let rl = l(data) || 0, rr = r(data) || 0, rla = Math.abs(rl), rra = Math.abs(rr);
        if (rla > rra)
          return rl;
        if (rla < rra)
          return rr;
        return Math.max(rl, rr);
      };
    }
  });

  // src/operators/and.js
  var require_and = __commonJS({
    "src/operators/and.js"(exports, module) {
      module.exports = (l, r) => (data) => {
        let rl = l(data) || 0, rr = r(data) || 0, rla = Math.abs(rl), rra = Math.abs(rr);
        if (rla > rra)
          return rr;
        if (rla < rra)
          return rl;
        return Math.min(rl, rr);
      };
    }
  });

  // src/operators/or-not.js
  var require_or_not = __commonJS({
    "src/operators/or-not.js"(exports, module) {
      module.exports = function(operators) {
        return (l, r) => (data) => {
          return operators["OR"](l, function(...args) {
            return -r(...args);
          })(data);
        };
      };
    }
  });

  // src/operators/and-not.js
  var require_and_not = __commonJS({
    "src/operators/and-not.js"(exports, module) {
      module.exports = function(operators) {
        return (l, r) => (data) => {
          return operators["AND"](l, function(...args) {
            return -r(...args);
          })(data);
        };
      };
    }
  });

  // src/operators/index.js
  var require_operators = __commonJS({
    "src/operators/index.js"(exports, module) {
      var operators = module.exports = {};
      operators["OR"] = require_or();
      operators["AND"] = require_and();
      operators["OR NOT"] = require_or_not()(operators);
      operators["AND NOT"] = require_and_not()(operators);
    }
  });

  // src/index.js
  var require_src = __commonJS({
    "src/index.js"(exports, module) {
      var lucene = module.exports = function factory(parser) {
        if (!parser) {
          throw new Error("No parser given. Must be one of 'lucene','lucene-queryparser','lucene-query-parser'");
        }
        if (typeof parser !== "object" || typeof parser.parse !== "function") {
          throw new Error("Incompatible parser given. Must be one of 'lucene','lucene-queryparser','lucene-query-parser'");
        }
        function compile(query) {
          if (!query)
            return () => 0;
          if (typeof query === "string") {
            try {
              query = parser.parse(query);
            } catch (e) {
              return () => 0;
            }
          }
          if (query.operator) {
            return lucene.operators[query.operator](compile(query.left), compile(query.right));
          }
          if (query.left) {
            return compile(query.left);
          }
          query.boost = query.boost || 1;
          for (const filter of lucene.filters) {
            if (filter.detect(query)) {
              return filter.compile(query);
            }
          }
          return () => 0;
        }
        compile.passthrough = function(parser2, query) {
          let match = compile(query);
          return function(data) {
            if (match(data))
              return data;
            return void 0;
          };
        };
        return compile;
      };
      lucene.filters = require_filters();
      lucene.operators = require_operators();
      if (typeof define === "function" && define.amd) {
        define(() => lucene);
      } else if (typeof window === "object") {
        window.lucene = lucene;
      }
    }
  });
  require_src();
})();
//# sourceMappingURL=index.js.map
